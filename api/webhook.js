export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    console.log('üéØ Webhook Zakeke re√ßu !');

    const product = req.body;
    
    if (isZakekeProduct(product)) {
      console.log('‚úÖ Produit Zakeke d√©tect√© !');
      
      // M√©thode 1: Chercher l'ID client dans les m√©tadonn√©es Zakeke
      const customerInfo = await extractCustomerFromZakeke(product);
      
      if (customerInfo.found) {
        console.log('üè¢ Client trouv√©:', customerInfo.companyName);
        console.log('üè∑Ô∏è Tag √† ajouter:', customerInfo.tag);
        
        // Ajouter le tag
        await addProductTag(product.id, customerInfo.tag);
        
        return res.status(200).json({ 
          status: 'success', 
          processed: true,
          productId: product.id,
          customerInfo: customerInfo,
          message: 'Tag client ajout√© avec succ√®s'
        });
      } else {
        console.log('‚ùå Impossible de trouver le client pour ce produit');
        return res.status(200).json({ 
          status: 'success', 
          processed: false,
          message: 'Client non trouv√©'
        });
      }
    }

    return res.status(200).json({ 
      status: 'success', 
      processed: false,
      message: 'Produit non-Zakeke'
    });

  } catch (error) {
    console.error('‚ùå Erreur webhook:', error);
    return res.status(500).json({ 
      error: 'Internal server error',
      message: error.message 
    });
  }
}

function isZakekeProduct(product) {
  return product.product_type === 'zakeke-design';
}

// Extraire le client depuis les donn√©es Zakeke
async function extractCustomerFromZakeke(product) {
  try {
    console.log('üîç Recherche du client dans les m√©tadonn√©es Zakeke...');
    
    // M√©thode 1: Depuis les m√©tadonn√©es du produit
    if (product.metafields) {
      console.log('üìä M√©tadonn√©es trouv√©es:', product.metafields.length);
      
      const customerMeta = product.metafields.find(m => 
        m.namespace === 'zakeke' && (m.key === 'customer_id' || m.key === 'customer_info')
      );
      
      if (customerMeta) {
        console.log('‚úÖ M√©tadonn√©e client trouv√©e:', customerMeta);
        const customerId = customerMeta.value;
        return await getCustomerData(customerId);
      }
    }
    
    // M√©thode 2: Depuis le HTML (data attributes Zakeke)
    if (product.body_html && product.body_html.includes('zakeke-product-tag')) {
      console.log('üîç Analyse du HTML Zakeke...');
      
      // Extraire les data attributes Zakeke
      const zaKekeMatches = product.body_html.match(/data-[^=]*="[^"]*"/g);
      if (zaKekeMatches) {
        console.log('üìä Data attributes Zakeke trouv√©s:', zaKekeMatches);
        
        // Chercher un ID de session ou customer
        for (const match of zaKekeMatches) {
          if (match.includes('customer') || match.includes('session') || match.includes('user')) {
            console.log('üéØ Attribut client potentiel:', match);
            // Extraire la valeur et chercher le client
            const value = match.match(/"([^"]*)"/)[1];
            const customerData = await getCustomerData(value);
            if (customerData.found) return customerData;
          }
        }
      }
    }
    
    // M√©thode 3: Chercher le client le plus r√©cemment modifi√© avec des tags
    console.log('üîç Recherche du client le plus r√©cent...');
    return await getRecentCustomerWithTags();
    
  } catch (error) {
    console.error('‚ùå Erreur extraction client:', error);
    return { found: false, error: error.message };
  }
}

// R√©cup√©rer les donn√©es d'un client sp√©cifique
async function getCustomerData(customerId) {
  try {
    console.log('üîç R√©cup√©ration client ID:', customerId);
    
    const response = await fetch(
      `https://${process.env.SHOPIFY_SHOP_DOMAIN}/admin/api/2024-01/customers/${customerId}.json`,
      {
        headers: {
          'X-Shopify-Access-Token': process.env.SHOPIFY_ACCESS_TOKEN
        }
      }
    );
    
    if (response.ok) {
      const customerData = await response.json();
      const customer = customerData.customer;
      
      console.log('‚úÖ Client trouv√©:', customer.email);
      console.log('üìù Note client:', customer.note);
      console.log('üè∑Ô∏è Tags client:', customer.tags);
      
      // Priorit√© 1: Tags existants du client
      if (customer.tags && customer.tags.includes('pro')) {
        const existingTag = customer.tags.split(',').find(tag => tag.trim().startsWith('pro'));
        if (existingTag) {
          return {
            found: true,
            customerId: customer.id,
            companyName: existingTag.trim(),
            tag: existingTag.trim(),
            source: 'customer_tags'
          };
        }
      }
      
      // Priorit√© 2: Note du client
      if (customer.note && customer
